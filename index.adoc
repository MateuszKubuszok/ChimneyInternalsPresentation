// 45 minutes
:revealjs_totalTime: 2700

= Unveiling the{nbsp}Magic

**Chimney's Internals, Macros & Scala 3 Transition**

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 8+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source - including cu-authoring Chimney
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should start with some excuse, why you even are here
--

== Agenda

[%step]
* what are Chimney's features
* what kind of code are we generating
* goals for the migration to Scala 2+3
* research and the current state

[NOTE.speaker]
--
I'll skip explaining why Chimney exists because previous presentation already dscussed the use cases.

I'll list features because it will help understand what we are generating and what we are supporting.
--

== Chimney's features

=== ``case class`` conversions

[source, scala]
--
import io.scalaland.chimney.dsl.* // assume this from now on
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double) // same fields

Foo(1, 2.0).transformInto[Bar] // Bar(1, 2.0)
--

[NOTE.speaker]
--
If every field in ``Bar`` has a corresponding field in ``Foo`` and fields don't have to be converted, transformation doesn't require any configuration.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, c: Double) // c instead of b

Foo(1, 2.0).into[Bar]
  .withFieldRenamed(_.b, _.c)
  .transform // Bar(1, 2.0)
--

[NOTE.speaker]
--
If we don't want to provide value because field can take value from another field we can use rename.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String) // extra field

Foo(1, 2.0).into[Bar]
  .withFieldConst(_.c, "test")
  .transform // Bar(1, 2.0, "test")
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String) // extra field

Foo(1, 2.0).into[Bar]
  .withFieldComputed(_.c, foo => foo.toString)
  .transform // Bar(1, 2.0, "Foo(1, 2.0)")
--

[NOTE.speaker]
--
If we have to fill an new field, we can use provide constant or compute the value.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String = "c") // ditto

Foo(1, 2.0).into[Bar]
  .enableDefaultValues
  .transform // Bar(1, 2.0, "c")
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: Option[String])//ditto

Foo(1, 2.0).into[Bar]
  .enableOptionDefaultsToNone
  .transform // Bar(1, 2.0, None)
--

[NOTE.speaker]
--
Or we can use some defaults if no other way is available but some default is accessible.
--

=== Tuples conversions

[source, scala]
--
case class Foo(a: Int, b: Double)

Foo(1, 2.0).transformInto[(Int, Double)] // (1, 2.0, None)
(1, 2.0).transformInto[Foo] // Foo(1, 2.0, None)
--

[NOTE.speaker]
--
If either side of a transformation is a tuple we match fields by their positions instead of names.
--

=== Java Beans conversions

[source, scala]
--
case class Foo(a: Int, b: Double)
class Bar private (
  @BeanProperty var a: Int,
  @BeanProperty var b: Double
) {
  def this() = this(0, 0.0)
}

Foo(1, 2.0).into[Bar].enableBeanSetters.transform

import scala.util.chaining.*
new Bar().pipe(_.setA(1)).pipe(_.setB(2.0))
  .into[Foo].enableBeanGetters.transform
--

[NOTE.speaker]
--
Instead of a case class we might use a Java Bean as well.
--

TODO method accessors

=== ``sealed`` hierarches conversions

[source, scala]
--
sealed trait Foo
object Foo {
  case object A extends Foo
  case class B(b: Int) extends Foo
}

sealed trait Bar // same subtypes
object Bar {
  case object A extends Foo
  case class B(b: Int) extends Bar
}

(Foo.A : Foo).transformInto[Bar] // Bar.A
(Foo.B(1) : Foo).transformInto[Bar] // Bar.B(1)
--

=== !

[source, scala]
--
sealed trait Foo
object Foo {
  case object A extends Foo
  case class B(b: Int) extends Foo
  case class C(c: Double) extends Foo
}
sealed trait Bar // missing Bar.C
object Bar {
  case object A extends Foo
  case class B(b: Int) extends Bar
}
(Foo.C(2.0) : Foo).into[Bar].withCoproductInstance[Foo.C] {
    case Foo.C(c) => Bar.B(c.toInt)
  }.transform // Bar.B(2)
--

=== ``AnyVal`` conversions

[source, scala]
--
case class Foo(val value: Int) extends AnyVal
case class Bar(val value: Int) extends AnyVal

Foo(1).transformInto[Bar] // Bar(1)
Foo(1).transformInto[Int] // 1
1.transformInto[Bar] // Bar(1)
--

=== Implicit ``Transformer``

=== Implicit ``TransformerConfiguration``

=== Partial Transformers

TODO: with

TODO: implicit resolutions

=== Patchers

== Generated code

=== Generating ``transformer(src)``?

TODO: old code with autogeneration

TODO: inliing

=== Calling ``unapply``?

=== Partial Transformers combinators?

TODO deferring results

TODO N = 1, N = 2, N > 2

== Migration's goals (Chimney 0.8.0)

[%step]
* source compatibility
* (excluding deprecated features which are removed)
* sharing as much code generation logic between Scala 2 and Scala 3 as possible

== Research for new Chimney internals

=== Scala 2 macros

TODO: codegen glued to an object

TODO quasiquotes

TODO prefix

TODO freshTerms

TODO Trees

TODO type checking

=== Scala 3 macros

TODO quote and unquote

TODO: no prefix

TODO quotes.relect

=== Common API?

TODO expr and type

== Questions?

== Thank You!
