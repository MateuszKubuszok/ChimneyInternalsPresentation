// 45 minutes
:revealjs_totalTime: 2700

= Unveiling the{nbsp}Magic

**Chimney's Internals, Macros & Scala 3 Transition**

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 8+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source - including cu-authoring Chimney
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should start with some excuse, why you even are here
--

== Agenda

[%step]
* what are Chimney's features
* what kind of code are we generating
* goals for the migration to Scala 2+3
* research and the current state

[NOTE.speaker]
--
I'll skip explaining why Chimney exists because previous presentation already dscussed the use cases.

I'll list features because it will help understand what we are generating and what we are supporting.
--

== Chimney's features

=== ``case class`` conversions

[source, scala]
--
import io.scalaland.chimney.dsl.* // assume this from now on
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double) // same fields

Foo(1, 2.0).transformInto[Bar] // Bar(1, 2.0)
--

[NOTE.speaker]
--
If every field in ``Bar`` has a corresponding field in ``Foo`` and fields don't have to be converted, transformation doesn't require any configuration.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, c: Double) // c instead of b

Foo(1, 2.0).into[Bar]
  .withFieldRenamed(_.b, _.c)
  .transform // Bar(1, 2.0)
--

[NOTE.speaker]
--
If we don't want to provide value because field can take value from another field we can use rename.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String) // extra field

Foo(1, 2.0).into[Bar]
  .withFieldConst(_.c, "test")
  .transform // Bar(1, 2.0, "test")
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String) // extra field

Foo(1, 2.0).into[Bar]
  .withFieldComputed(_.c, foo => foo.toString)
  .transform // Bar(1, 2.0, "Foo(1, 2.0)")
--

[NOTE.speaker]
--
If we have to fill an new field, we can use provide constant or compute the value.
--

=== !

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: String = "c") // ditto

Foo(1, 2.0).into[Bar]
  .enableDefaultValues
  .transform // Bar(1, 2.0, "c")
--

[source, scala]
--
case class Foo(a: Int, b: Double)
case class Bar(a: Int, b: Double, c: Option[String])//ditto

Foo(1, 2.0).into[Bar]
  .enableOptionDefaultsToNone
  .transform // Bar(1, 2.0, None)
--

[NOTE.speaker]
--
Or we can use some defaults if no other way is available but some default is accessible.
--

=== Tuples conversions

[source, scala]
--
case class Foo(a: Int, b: Double)

Foo(1, 2.0).transformInto[(Int, Double)] // (1, 2.0, None)
(1, 2.0).transformInto[Foo] // Foo(1, 2.0, None)
--

[NOTE.speaker]
--
If either side of a transformation is a tuple we match fields by their positions instead of names.
--

=== Java Beans conversions

[source, scala]
--
case class Foo(a: Int, b: Double)
class Bar private (
  @BeanProperty var a: Int,
  @BeanProperty var b: Double
) {
  def this() = this(0, 0.0)
}

Foo(1, 2.0).into[Bar].enableBeanSetters.transform

import scala.util.chaining.*
new Bar().pipe(_.setA(1)).pipe(_.setB(2.0))
  .into[Foo].enableBeanGetters.transform
--

[NOTE.speaker]
--
Instead of a case class we might use a Java Bean as well.
--

=== !

[source, scala]
--
class Foo {
  def a: Int = 1
}

case class Bar(a: Int)

Foo(1).into[Bar].enableMethodAccessors.transform
--

[NOTE.speaker]
--
By default only ``case class`` fields are takein into consideration.
--

=== ``sealed`` hierarches conversions

[source, scala]
--
sealed trait Foo
object Foo {
  case object A extends Foo
  case class B(b: Int) extends Foo
}

sealed trait Bar // same subtypes
object Bar {
  case object A extends Foo
  case class B(b: Int) extends Bar
}

(Foo.A : Foo).transformInto[Bar] // Bar.A
(Foo.B(1) : Foo).transformInto[Bar] // Bar.B(1)
--

=== !

[source, scala]
--
sealed trait Foo
object Foo {
  case object A extends Foo
  case class B(b: Int) extends Foo
  case class C(c: Double) extends Foo
}
sealed trait Bar // missing Bar.C
object Bar {
  case object A extends Foo
  case class B(b: Int) extends Bar
}
(Foo.C(2.0) : Foo).into[Bar].withCoproductInstance[Foo.C] {
    case Foo.C(c) => Bar.B(c.toInt)
  }.transform // Bar.B(2)
--

[NOTE.speaker]
--
There is an interesting duality between products and coproducts: products require that all output fields have sources, and coproducts require that all input types have targets.
--

=== ``AnyVal`` conversions

[source, scala]
--
case class Foo(val value: Int) extends AnyVal
case class Bar(val value: Int) extends AnyVal

Foo(1).transformInto[Bar] // Bar(1)
Foo(1).transformInto[Int] // 1
1.transformInto[Bar] // Bar(1)
--

=== Implicit ``Transformer``

[source, scala]
--
class SomeType(val x: Int)
class AnotherType(val y: Int)

case class Foo(a: SomeType, b: Int)
case class Bar(a: AnotherType, b: Int)

foo.transformInto[Bar] // error: how to convert foo.a?
--

[%step]
[source, scala]
--
import io.scalaland.chimney.Transformer

implicit val someTypeToAnotherType:
   Transformer[SomeType, AnotherType] =
  st => new AnotherType(y = st.x) // single abstract method

foo.transformInto[Bar]//uses someTypeToAnotherType for foo.a
--

[NOTE.speaker]
--
This shows the true power of Chimney as transformetions can be generated recursively and then we only have to manually plug-in the types which cannot be figured out.
--

=== Implicit ``TransformerConfiguration``

[source, scala]
--
implicit val cfg = TransformerConfiguration.default
  .enableDefaultValues
  .enableOptionDefaultsToNone
  .enableBeanGetters
  .enableBeanSetters

// now .into.transform and .transformInto use above flags
--

=== Partial Transformers

[source, scala]
--
case class Foo(a: Option[Int])
case class Bar(a: Int)

Foo(None).transformInto[Bar] // cannot handle None!
--

[%step]
[source, scala]
--
val result = Foo(None).transformIntoPartial[Bar]
result.asEither // Left(...)
result.asErrorPathMessages
  // Iterable("a" -> ErrorMessage.EmptyValue)
--

=== !

[source, scala]
--
implicit val intToString:
    Transformer[Int, String] =
  int => int.toString

implicit val stringToInt:
    PartialTransformer[String, Int] =
  PartialTransformer { str =>
    partial.Result.fromCatching(str.toInt)
  }

case class Foo(a: Option[Int], b: String)
case class Bar(a: String, b: Int)

Foo(None, "test").transformIntoPartial[Bar]
--

[NOTE.speaker]
--
Partial has all the properties of toral transformers and more.
--

=== !

[source, scala]
--
// from is case class
from.intoPartial[To]
  // total operations
  .withFieldRenamed(_.a, _.b)
  .withFieldConst(_.c, value)
  .withFieldComputed(_.d, from => ...)
  // partial operations
  .withFieldComputedPartial(_.e, from => ...)
  .transform
--

[source, scala]
--
// from is sealed hierarchy
from.intoPartial[To]
  // total operations
  .withCoproductInstance[To.Subtype](...)
  // partial operations
  .withCoproductInstancePartial[To.Subtype](...)
  .transform
--

=== !

[source, scala]
--
implicit val totalInt2String:
    Transformer[String, Int] =
  str => scala.util.Try(str.toInt).getOrElse(0)

implicit val stringToInt:
    PartialTransformer[String, Int] =
  PartialTransformer { str =>
    partial.Result.fromCatching(str.toInt)
  }

case class Foo(a: String)
case class Bar(a: Int)

Foo(1).transformIntoPartial[Bar] // error: ambiguity!
--

[%step]
[source, scala]
--
implicit val cfg = TransformerConfiguration.default
 .enableImplicitConflictResolution(PreferTotalTransformer)
 /* or
 .enableImplicitConflictResolution(PreferPartialTransformer)
 */
--

TODO: fail fast

TODO error reporting

=== Patchers

[source, scala]
--
case class Foo(a: Int, b: String, c: Double)
case class Patch(c: Double)

Foo(1, "2", 3.0).patchUsing(Patch(4.0)) // Foo(1, "2", 4.0)
--

[NOTE.speaker]
--
Patchers are currently shallow, they don't update things in-depth, and only support ``case class``es.
--

== Generated code

=== Are we generating ``new Transformer``s?

[source, scala]
--
case class Foo(a: Int, b: String)
case class Bar(a: Int, b: String)

Foo(1, "b").transformInto[Bar]
--

Do we generate:

[source, scala]
--
new Transformer {
  def transform(foo: Foo): Bar = Bar(
    Transformer.identity[Int].transform(foo.a),
    Transformer.identity[String].transform(foo.b)
  )
}.transform(Foo(1, "b"))
--

?

[NOTE.speaker]
--
Answer: in the old times when it was a Shapeless project, we did, but for many years we don't.
--

=== !

[source, scala]
--
val compilerGeneratedName = Foo(1, "b")
Bar(
  compilerGeneratedName.a,
  compilerGeneratedName.b
)
--

[NOTE.speaker]
--
Actually, what Chimney generates is the expression with the target type. Everything is inlined from the start.
--

=== !

TODO: nested example

=== !

TODO when there is implicit

=== !

define

=== Calling ``unapply``?

=== Partial Transformers combinators?

TODO deferring results

TODO N = 1, N = 2, N > 2

== Migration's goals (Chimney 0.8.0)

[%step]
* source compatibility
* (excluding deprecated features which are removed)
* sharing as much code generation logic between Scala 2 and Scala 3 as possible

== Research for new Chimney internals

=== Scala 2 macros

TODO: codegen glued to an object

TODO quasiquotes

TODO prefix

TODO freshTerms

TODO Trees

TODO type checking

=== Scala 3 macros

TODO quote and unquote

TODO: no prefix

TODO quotes.relect

=== Common API?

TODO expr and type

=== Technical debt

TODO the actual reason Chimney migration takes this long

== Questions?

== Thank You!
